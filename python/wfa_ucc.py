###################################################################
# (c) Copyright 2008 Wi-Fi Alliance.  All Rights Reserved
#
# Authors:
# Qiumin Hu;       Email: qhu@wi-fi.org
# Ankur Vachhani;  Email: avachhani@wi-fi.org
####################################################################
# LICENSE
####################################################################
#
#
# License is granted only to Wi-Fi Alliance members and is for use solely
# in testing Wi-Fi products. This license is not transferable or sublicensable,
# and it does not extend to and may not be used with non Wi-Fi applications.
#
# Commercial derivative works or applications that use the Wi-Fi
# scripts generated by this software are NOT AUTHORIZED without
# specific prior written permission from Wi-Fi Alliance
#
# Non-commercial derivative works for your own internal use are
# authorized and are limited by the same restrictions.
#
# Neither the name of the author nor "Wi-Fi Alliance"
# may be used to endorse or promote products that are derived
# from or that use this software without specific prior written
# permission from the author or Wi-Fi Alliance
#
# THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY
# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
# FOR A  PARTICULAR PURPOSE, ARE DISCLAIMED. IN NO EVENT SHALL WI-FI
# ALLIANCE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# THE COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
###################################################################
# Change History
#       Date        Version          Comment 
#       12/5/2007    0.1             Initial Prototype release for WMM
#        
###################################################################
#


#!/usr/bin/evn python
import os, sys
from myutils import scanner
from myutils import process_ipadd
from myutils import process_cmdfile
from myutils import firstword
from myutils import init_logging
from myutils import printStreamResults 
from myutils import close_conn
from myutils import wfa_sys_exit
from myutils import setUCCPath
import logging
import time
nargs = len(sys.argv)

def main():

    if nargs < 4 :
        print('Incorrect Command line !!! \n\rUSAGE : <program name> <console logging level> <Init Filename> <TestCase command file>\
        \n\r      logging level : 0 - Logging disable\
        \n\r                      1 - Logging enable (info level)\
	\n\r                      2 - Logging enable (debug level)\
	\n\r\n\r      Init File Name : Initializtion file for program\
	\n\r\n\r      Testcase Command File Name : Command File Name for test case.\
        \n\r        For example, WMM-S2-T04.txt to run Step 4 of WMM S2 test case.\
        \n\r\n\rSAMPLE - c:\python25\python.exe 1 ..\\..\\cmds\\init_WMM.txt ..\\..\\cmds\\WMM-S2-T04.txt\
    	')
	wfa_sys_exit("")
    
    init_logging(sys.argv[3],sys.argv[1])
    uccPath = os.getenv("UCC_CMD_PATH")
    init=sys.argv[2]
    cmd=sys.argv[3]
    if (uccPath):
        logging.info("UCC CMD Path = %s" % uccPath)
    else:
        uccPath="..\..\cmds"
        logging.info("UCC cmd Path = %s " % uccPath)

    uccPath=uccPath.strip()
    if (uccPath.endswith('\\') == 0 ):
        uccPath=uccPath + '\\'

    setUCCPath(uccPath)
    init=uccPath+init
    cmd=uccPath + cmd

    if os.path.exists(init) == 0:
        logging.error ("Invalid file name - %s" % init)
        wfa_sys_exit("1")
    else :
        initfile = init
    
    if os.path.exists(cmd) == 0:
        logging.error ("Invalid file name - %s" % cmd)
        wfa_sys_exit("1")
    logging.info("\n %7s Testcase Init File = %s \n" %( "",init))
    logging.info("\n %7s Testcase Command File = %s \n" % ("",cmd))
    file = open(initfile)
    scanner(file, firstword)
    process_cmdfile(cmd)
    
    #delay for last receive_stop response
    time.sleep(5)
    printStreamResults()
    file.close()
    close_conn()
    time.sleep(2)

if __name__ == "__main__":
    main()
