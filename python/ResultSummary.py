###################################################################
# (c) Copyright 2011 Wi-Fi Alliance.  All Rights Reserved
#
# Authors:
# Ankur Vachhani;  Email: avachhani@wi-fi.org
####################################################################
# LICENSE
####################################################################
#
#
# License is granted only to Wi-Fi Alliance members and is for use solely
# in testing Wi-Fi products. This license is not transferable or sublicensable,
# and it does not extend to and may not be used with non Wi-Fi applications.
#
# Commercial derivative works or applications that use the Wi-Fi
# scripts generated by this software are NOT AUTHORIZED without
# specific prior written permission from Wi-Fi Alliance
#
# Non-commercial derivative works for your own internal use are
# authorized and are limited by the same restrictions.
#
# Neither the name of the author nor "Wi-Fi Alliance"
# may be used to endorse or promote products that are derived
# from or that use this software without specific prior written
# permission from the author or Wi-Fi Alliance
#
# THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY
# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
# FOR A  PARTICULAR PURPOSE, ARE DISCLAIMED. IN NO EVENT SHALL WI-FI
# ALLIANCE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# THE COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
###################################################################
# Change History
#        
###################################################################
#


#!/usr/bin/evn python
import os, sys
import logging
import logging.handlers
import time
import xml.dom.minidom
import inspect
import re
import subprocess

from xml.dom.minidom import Document
from xml.dom.minidom import getDOMImplementation
from xml.dom.minidom import parse
from xml.dom.minidom import Node


# Override createElement:
class XMLDoc(Document):
    
    def createElement(self, tag, textNode=None):      
        el = Document.createElement(self,"%s" % tag)
        el.doc = self
        if textNode:
            el.appendChild(self.createTextNode(textNode))
        return el



    
class TBDevice:
    def __init__(self,vendor,model,driver,os,SigmaControlAgent):
        self.vendor=vendor
        self.model=model
        self.driver=driver
        self.os=os
        self.SigmaControlAgent=SigmaControlAgent
        self.verified=0
        self.msg=""
        
        #logging.info("TBDevice Object created:%s:%s:%s:%s:%s"%(self.vendor,self.model,self.driver,self.os,self.SigmaControlAgent))
    def AddXMLNode(self,doc,parent,ver=0):
        device = doc.createElement("Device")
        parent.appendChild(device)

        device.appendChild(doc.createElement("Vendor",self.vendor))
        device.appendChild(doc.createElement("Model",self.model))
        device.appendChild(doc.createElement("Driver",self.driver))
        device.appendChild(doc.createElement("OS",self.os))
        device.appendChild(doc.createElement("SigmaControlAgent",self.SigmaControlAgent))

        #Check if verification node to be added
        if ver:
            logging.debug("TBDevice::AddXMLNode : ver")
            verification = doc.createElement("Verification")
            if self.verified : status = "OK"
            else: status = "Mismatch"
        
            verification.appendChild(doc.createElement("Status",status))
            verification.appendChild(doc.createElement("Message",self.msg))

            device.appendChild(verification)

    def compare(self,node):
        #logging.debug("comparing two TBDevice node %s %s" % (self,node))
        rc=0
        if self.vendor.lower() != node.vendor.lower():
            rc=0
        else:
            if self.model.lower() != node.model.lower():
                rc=("%s\n Model - Expected:%s \n-OR-" % (self.msg,node.model))
            if self.driver.lower() != node.driver.lower():
                rc=("%s\n Driver - Expected:%s \n-OR-" % (self.msg,node.driver))
            if self.SigmaControlAgent.lower() != node.SigmaControlAgent.lower():
                rc=("%s\n Sigma Control Agent Expected:%s \n-OR-" % (self.msg,node.SigmaControlAgent))
            
            if rc: self.msg=rc
            else: self.verified=1
            
        #logging.debug("TBDevice::compare return %s-%s-" % (rc,self.verified))
        return rc
    def __str__(self):
        #return("\n TBDevice Object :%s:%s:%s:%s:%s"%(self.vendor,self.model,self.driver,self.os,self.SigmaControlAgent))
        pass

class SigmaComponent:
    
    def __init_(self,name,version="",others=""):
        self.name=name
        self.version=version
        self.others=others
        
    def AddXMLNode(self,doc,parent):
        #print ("SigmaComponent::AddXMLNode [%s] [%s]" % (doc,parent)) 
        Sigma = doc.createElement("SigmaComponent")
        parent.appendChild(Sigma)

        Sigma.appendChild(doc.createElement("Name",self.name))
        Sigma.appendChild(doc.createElement("Version",self.version))
        Sigma.appendChild(doc.createElement("Others",self.others))

    def __str__(self):
        pass
    
class LogFile:
    def __init__(self,name,signature):
        self.name=name
        self.signature=signature

    def __str__(self):
        pass
        
class TestCase:
    def __init__(self,testID,result,r1="",r2="",logfiles=[]):
        self.testID=testID
        self.result=result
        self.r1=r1
        self.r2=r2
        self.logfiles=[]
        self.totalRun=0
        self.nPass=0
        self.nFail=0
        self.nErr=0
        self.type=""
        self.optionalFeature=""

    def AddXMLNode(self,doc,parent):
        TestCase = doc.createElement("TestCase")
        parent.appendChild(TestCase)

        TestCase.appendChild(doc.createElement("TestID",self.testID))
        TestCase.appendChild(doc.createElement("Result",self.result))
        TestCase.appendChild(doc.createElement("R1",self.r1))
        TestCase.appendChild(doc.createElement("R2",self.r2))
        LogFiles = doc.createElement("LogFiles")
        
        for l in self.logfiles:
             LogFile = doc.createElement("LogFile")
             LogFile.appendChild(doc.createElement("Name",l.name))
             LogFile.appendChild(doc.createElement("Signature",l.signature))
             LogFiles.appendChild(LogFile)             

        Stats= doc.createElement("Stats")
        TestCase.appendChild(Stats)
        Stats.appendChild(doc.createElement("TotalRun","%s" % self.totalRun))
        Stats.appendChild(doc.createElement("TotalPASS","%s" % self.nPass))
        Stats.appendChild(doc.createElement("TotalFAIL","%s" % self.nFail))
        Stats.appendChild(doc.createElement("TotalERROR","%s" % self.nErr))
        TestCase.appendChild(LogFiles)

        TestCase.appendChild(doc.createElement("Type",self.type))

        if self.type == "Optional":
            TestCase.appendChild(doc.createElement("OptionalFeature",self.optionalFeature))

    def __str__(self):
        pass

class ResultSummary:
    def __init__(self,fileName,TestCriteriaFile,Prog,uid="",logpath="",mChk=1,stylesheet="Results-Format.xsl"):
        self.fileName=fileName
        self.TestResults=""
        self.doc=XMLDoc()
        self.uid=uid
        self.logpath=logpath
        self.versionInfoFlag=0
        self.testplanVersion=""
        self.testplanID=""
        self.sigKeyID=""
        self.TestCases=[]
        self.ProgramName=Prog
        self.TestCriteriaFile=xml.dom.minidom.parse(TestCriteriaFile)
        # Stylesheet
        self.doc.appendChild(self.doc.createProcessingInstruction("xml-stylesheet",
	"type=\"text/xsl\" href=\"%s\"" % stylesheet))

        
        # Results->Result->Info
        # Results->Result->TestResults      
        self.Results = self.doc.createElement("Results")
        self.Result = self.doc.createElement("Result")
        self.ResultInfo = self.doc.createElement("Info")
        self.TestResults = self.doc.createElement("TestResults")
        
        self.doc.appendChild(self.Results)
        self.Results.appendChild(self.Result)
        self.Result.appendChild(self.ResultInfo)
        self.Result.appendChild(self.TestResults)

        self.ResultInfo.appendChild(self.doc.createElement("ProgramName",self.ProgramName))
        self.ResultInfo.appendChild(self.doc.createElement("time", "%s" % time.strftime("%Y-%m-%dT%H:%M:%SZ", time.localtime())))
        self.ResultInfo.appendChild(self.doc.createElement("UID",self.uid))
        self.ResultInfo.appendChild(self.doc.createElement("TestplanVersion",self.testplanVersion))
        self.ResultInfo.appendChild(self.doc.createElement("TestCriteriaFileVersion",self.getAttrValue(self.TestCriteriaFile,"ConfigSets","Version")))
        self.ResultInfo.appendChild(self.doc.createElement("TestplanID",self.testplanID))
        self.ResultInfo.appendChild(self.doc.createElement("SignatureKeyID",self.sigKeyID))

        self.mChk=mChk
        
    def addVersionInfo(self,dlog):
        
        Testbed = getNodeHandle(dlog,["Log","Info","Testbed"])

        # Add verified Testbed information in results summary
        vTestbed=self.doc.createElement("Testbed")
        
        if Testbed:
            # List of valid config sets from TestCriteriaFile
            tRight = getNodeHandle(self.TestCriteriaFile,["ConfigSets",self.ProgramName,"ConfigSet"],"",1)           
            t = getNodeHandle(dlog,["Log","Info","Testbed","Device"],"",1)
            
            if t:
                for tLeft in t:
                    l=self.compareTwoTBNodes(tLeft,tRight) 
                    l.AddXMLNode(self.doc,vTestbed,1)
                    
                self.Result.appendChild(vTestbed)

        DUT = getNodeHandle(dlog,["Log","Info","DUT"])
        if DUT:
            self.Result.appendChild(DUT)

        Sigma = getNodeHandle(dlog,["Log","Info","Sigma"])
        if Sigma:
            self.Result.appendChild(Sigma)

        self.versionInfoFlag=1
        
    def generateSummary(self):
        
        for f1 in os.listdir(self.logpath):
          logging.debug("Folder name [%s]" % f1)
          
          if f1.startswith(self.ProgramName):
            for f in os.listdir(self.logpath + "\\" + f1):
                logging.debug("--File name [%s]" % f)
                #if len(f.split('.')) > 1 and f.split('.')[1] == "xml":
                if f.endswith(".xml"):
                    lf= "%s%s/%s" % (self.logpath,f1,f)
                    logging.info ("Processing log file - %s \n", lf)
                    dlogFile = xml.dom.minidom.parse(lf)
                    if not self.versionInfoFlag:
                        self.addVersionInfo(dlogFile)
                    tID = self.getAttrValue(dlogFile,"Log","id")
                    tResult = self.getNodeValue(dlogFile,"Log","TestCaseResult")
                    #sig=self.getNodeValue(dlogFile,"Log","Signature")
                    sig="1"
                                    
                    # Add result nodes to TestCase
                    if tID and tResult: 
                        tList=""
                        # check if test already present
                        for tList in self.TestCases:
                            if tList.testID == tID:break
                            logging.debug("%s" % tList.testID)

                        # Always pick the latest results    
                        if tList=="" or tList.testID != tID:
                            t1=TestCase(tID,tResult)
                            self.TestCases.append(t1)
                        else:
                            t1=tList
                            t1.result=tResult
                            
                        if tResult == "PASS" or tResult == "PASSED" or tResult == "COMPLETED":
                            t1.nPass = int(t1.nPass) + 1
                            
                        elif tResult == "FAILED" or tResult =="FAIL":
                            t1.nFail = int(t1.nFail) + 1
                        else:
                            #Check if manual check should be done
                            mchkInfo=self.getNodeValue(dlogFile,"Log","ManualCheckInfo")
                            if self.mChk and mchkInfo:
                                os.startfile(self.logpath + "\\" + f1)
                                var = raw_input("-Manual Analysis Needed- Test ID -[%s]\n %s \n\n-Enter the result [P or F]: " % (tID, mchkInfo))
                                t1.result=var
                                if var=="P":
                                    t1.nPass = int(t1.nPass) + 1
                                    t1.result="PASS"
                                else:
                                     t1.nFail = int(t1.nFail) + 1
                                     t1.result="FAILED"
                                
                            else:
                                t1.nErr = int(t1.nErr) + 1
                            
                        t1.totalRun = t1.totalRun + 1
                            
                        t1.logfiles.append(LogFile(lf,sig))


        testList = getNodeHandle(self.TestCriteriaFile,["ConfigSets",self.ProgramName,"TestCases","TestCase"],"",1)            
        for t in testList:
            for tList in self.TestCases:
                iTestFound = 0
                tID = self.getNodeValue(t,"TestCase","TestID")
                if tID == tList.testID:
                    printNode(t)
                    iTestFound = 1
                    tList.type=self.getNodeValue(t,"TestCase","Type")
                    if tList.type == "Optional":
                        tList.optionalFeature=self.getNodeValue(t,"TestCase","OptionalFeature")
                        
                    tList.AddXMLNode(self.doc,self.TestResults)
                    break
                
                # If results not found for the test, mark it mising
                if not iTestFound:
                    tMissing = TestCase(tID,"NO Results Found")
                    tMissing.type=self.getNodeValue(t,"TestCase","Type")
                    if tMissing.type == "Optional":
                        tMissing.optionalFeature=self.getNodeValue(t,"TestCase","OptionalFeature")
                    tMissing.AddXMLNode(self.doc,self.TestResults)
                    
        
            

    def getAttrValue(self,node,tag,attr):
        #return the first match
         for n in node.getElementsByTagName(tag):
             return n.attributes[attr].value

    def getNodeValue(self,node,tag,attr):
        #return the first match
            for l in node.getElementsByTagName(attr):
                logging.debug(l)
                return l.firstChild.data
            
    def getTBDeviceObject(self,node):
       lList={}
       # convert all string to lower case for comparision
       for n in node.getElementsByTagName("*"):
           lList.setdefault(n.tagName.strip(),n.firstChild.data.strip())
           
       return(TBDevice(lList["Vendor"],lList["Model"],lList["Driver"],lList["OS"],lList["SigmaControlAgent"]))
        
    def compareTwoTBNodes(self,left,right):
        logging.debug ("TLeft = %s TRight = %s" % (left,right))
    
        lTBDevice = self.getTBDeviceObject(left)
        #print rList["Vendor"]
        for r in right:
            rightList = getNodeHandle(r,["ConfigSet","Testbed","Device"],r,1)
            for d in rightList:
                rTBDevice =self.getTBDeviceObject(d)                
                lTBDevice.compare(rTBDevice)
                if lTBDevice.verified: break
            if lTBDevice.verified: break

        if lTBDevice.verified == 0:
            logging.debug (lTBDevice.msg)
            
        return lTBDevice
            
    def writeXML(self):                     
        #print self.doc.toprettyxml(indent="  ")
        fXMLFile = open(self.fileName,"w")
        fXMLFile.write(self.doc.toprettyxml(indent=" "))
        fXMLFile.close()
        return
        
class ResultValidation:
    def __init__(self,SummaryFile,TestCriteriaFile,ProgramName):
        self.SummaryFile=xml.dom.minidom.parse(SummaryFile)
        self.TestCriteriaFile=xml.dom.minidom.parse(TestCriteriaFile)
        self.ProgramName=ProgramName
        self.result="PASS"
        self.msgs=["msg1","msg2"]

        logging.debug("Summary File = %s TestCriteriaFile = %s" %(SummaryFile,TestCriteriaFile))
  

    
def printNode(node):

       for n in node.getElementsByTagName("*"):
           logging.debug("[%s]=[%s] " % (n.tagName.strip(),n.firstChild.data.strip()))
          

def _get_elements_by_tagName_helper(parent, name, rc):
    
    for node in parent.childNodes:
        if node.nodeType == Node.ELEMENT_NODE and (name == "*" or node.tagName == name):
            rc.append(node)

    return rc

#Get the node handle for given depth of node name in tagList
def getNodeHandle(node,tagList,string="",lst=0):
         TagCounter = 0
         nHandle=[]
         if string:
             node=xml.dom.minidom.parseString(string.toprettyxml(indent=" "))
             
         #logging.debug("TAG Length = %s" % len(tagList))
         while TagCounter < len(tagList):
             nHandle=[]
             _get_elements_by_tagName_helper(node,tagList[TagCounter],nHandle)
                              
             logging.debug("Level = %s Element = %s Search %s"  % (TagCounter,nHandle,tagList[TagCounter]))
             if nHandle==[]:
                 break
             else:
                 node=nHandle[0]
                 
             TagCounter = TagCounter + 1

         #return the first match            
         if nHandle:
             if lst:
                 return nHandle
             else:
                 return nHandle[0]
            
      
def init_logging (_filename):

    logging.basicConfig(level=logging.DEBUG,
        format='%(message)s',
        datefmt='%a, %d %b %Y %H:%M:%S',
        filename=_filename,
        filemode='w')
    console = logging.StreamHandler()
   
    console.setLevel(logging.INFO)
    
    formatter = logging.Formatter('%(message)s')
    console.setFormatter(formatter)
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)

    
    logging.info ("###########################################################\n")    
    logging.info('Debug log in file - %s' % (_filename))


def main():

    if nargs < 4 :
        print('\n\rUSAGE : ResultSummary <output file name> <program name> <UID> \
        \n\r Output File Name : The result summary file name \
        \n\r Program Name     : WFA Program Name [HS2/WFD/P2P/PMF/N/WPA2/WMM] \
	\n\r UID              : Unique identifier for the result summary. You can use any number or string to uniquely identify the summary that you are generating.\
        \n\n\n\r\n\r        For example, ResultSummary P2P CID12345\
    	')
	exit(0)
    

    if not sys.argv[1].startswith(".xml"):
        f= "%s.xml" % sys.argv[1]
    else:
        f=sys.argv[1]

    #Skip manual check. Enable by default
    sm=1
    
    if nargs > 4 and sys.argv[4]=="0":
        sm=0
    
    rSummary = ResultSummary(f,"TestCriteria.xml",sys.argv[2],sys.argv[3],"./log/",sm)
    init_logging("debug-log-result-summary.txt")
    rSummary.generateSummary()
    rSummary.writeXML()
    
    # valid results C:\MyDocs\Self-Cert\Self-Cert_Result-Files\TestCriteria\TestCriteria.xml
    #validator = ResultValidation(rSummary.fileName,"C:\\MyDocs\\Self-Cert\\Self-Cert_Result-Files\\TestCriteria\\TestCriteria.xml",rSummary.ProgramName)
    #validator.validate()
    #logging.info("%s" % validator)

nargs = len(sys.argv)    
if __name__ == "__main__":
    main()
